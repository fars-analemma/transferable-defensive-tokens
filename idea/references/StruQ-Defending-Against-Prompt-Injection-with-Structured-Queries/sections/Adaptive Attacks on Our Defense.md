Adaptive Attacks on Our Defense
We tried to attack our own system, seeking to devise adaptive attacks tailored with knowledge of how our system works. The strongest attack we could find is to try to evade the frontend's filters using "near-miss" delimiters that are similar to but slightly different from the delimiters our system was trained on. The filter stops Completion attacks that use the exact same delimiters as our front-end uses, but it does not filter out other delimiters, so we evaluated whether an attacker could construct alternative delimiters that would not be filtered but would fool the LLM. Specifically, we tested nine variants on the standard delimiters. We modify the default delimiters (e.g., "### instruction:", which contains three hash marks, a blank space, a lower-case word, and a colon) to create many variants. Specifically, we vary the number of of hash marks, with or without blank space, different cases, and with or without colon. We also inject typos into the word by randomly choosing one character to perturb. Finally, we try replacing each word (i.e., "instruction", "input", or "response") with another word of similar meaning, selected by randomly choosing a single-token word among those whose embedding has the highest cosine similarity to the original word. Table 4 shows the effectiveness of Completion attacks using these variant delimiters. Against an undefended LLM, Completion attacks with these "near-miss" delimiters are nearly as effective as Completion attacks with the real delimiters. However, after structured instruction tuning, Completion attacks with "near-miss" delimiters are no longer effective, thanks to our special reserved tokens. This is because correct delimiters are encoded to our reserved tokens, but "near-miss" delimiters are encoded to other tokens, and structured instruction tuning is sufficient to teach the model to ignore them. We also try changing [INST] to [inst], [Inst], #INST#, or [[INST]] (and similarly for other special delimiters) in Completion-Real attacks; all have 0% ASR. The reason is that [INST] is tokenized to a reserved token, but other variants are tokenized like ordinary text. The resulting large change in embedding makes such attacks unsuccessful. Without a filter, Completion attacks with real delimiters would be effective, but our filter stops this attack. As a result, StruQ stops all Completion attacks we were able to design: attacks using the real delimiters are stopped by the front-end's filter, and attacks with "near-miss" delimiters are stopped by structured instruction tuning. Therefore, StruQ is very unlikely to be fooled by delimiters close to the real delimiters, let alone others that are more dissimilar.

[TABLE START]Table 4 : Adaptive attacks by Completion attacks using different delimiters. The real delimiters are '### response:' and '### instruction:', and others are modified from the real ones by changing them in one way. The first two variants are stopped by our front-end's filter; the remainder are unfiltered. <table><row><cell/><cell cols="2">Llama</cell><cell cols="2">Mistral</cell></row><row><cell/><cell cols="4">Undef. Ours Undef. Ours</cell></row><row><cell>Real delim.</cell><cell>96%</cell><cell>0%</cell><cell>90%</cell><cell>0%</cell></row><row><cell>2 hash marks</cell><cell>90%</cell><cell>0%</cell><cell>90%</cell><cell>0%</cell></row><row><cell>1 hash mark</cell><cell>91%</cell><cell>1%</cell><cell>90%</cell><cell>0%</cell></row><row><cell>0 hash mark</cell><cell>90%</cell><cell>0.5%</cell><cell>90%</cell><cell>0%</cell></row><row><cell>All upper case</cell><cell>92%</cell><cell>0%</cell><cell>92%</cell><cell>0%</cell></row><row><cell>Title case</cell><cell>89%</cell><cell>0%</cell><cell>93%</cell><cell>0%</cell></row><row><cell>No blank space</cell><cell>90%</cell><cell>0%</cell><cell>93%</cell><cell>0%</cell></row><row><cell>No colon</cell><cell>90%</cell><cell>0%</cell><cell>93%</cell><cell>0%</cell></row><row><cell>Typo</cell><cell>85%</cell><cell>0%</cell><cell>91%</cell><cell>0%</cell></row><row><cell>Similar token</cell><cell>61%</cell><cell>0%</cell><cell>73%</cell><cell>0%</cell></row></table>[TABLE END]
